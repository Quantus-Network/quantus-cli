//! `quantus merkle-airdrop` subcommand - manage token airdrops via Merkle proofs
use crate::{
	chain::{client::QuantusClient, quantus_subxt},
	cli::{
		common::{resolve_address, submit_transaction},
		send::{format_balance, get_chain_properties, parse_amount},
	},
	error::Result,
	log_error, log_info, log_print, log_success, log_verbose,
};
use clap::Subcommand;
use codec::Encode;
use colored::Colorize;
use serde::{Deserialize, Serialize};
use sp_core::crypto::{AccountId32 as SpAccountId32, Ss58Codec};
use std::collections::HashMap;

/// Quantus chain always uses 12 decimals
const QUANTUS_DECIMALS: u32 = 12;

/// Load merkle root from JSON file
fn load_merkle_root_from_file(file_path: &str) -> Result<String> {
	let content = std::fs::read_to_string(file_path).map_err(|e| {
		crate::error::QuantusError::Generic(format!("Failed to read file {}: {}", file_path, e))
	})?;

	let data: MerkleTreeOutput = serde_json::from_str(&content)
		.map_err(|e| crate::error::QuantusError::Generic(format!("Failed to parse JSON: {}", e)))?;

	Ok(data.root)
}

/// MerkleAirdrop management commands
#[derive(Subcommand, Debug)]
pub enum MerkleAirdropCommands {
	/// Create a new airdrop with Merkle root
	Create {
		/// Merkle root (32-byte hex string, with or without 0x prefix)
		#[arg(long, conflicts_with = "merkle_file")]
		merkle_root: Option<String>,

		/// Load merkle root from JSON file (generated by generate-tree)
		#[arg(long, conflicts_with = "merkle_root")]
		merkle_file: Option<String>,

		/// Optional vesting period in blocks (e.g., "28800" for ~2 days with 6s blocks)
		#[arg(long)]
		vesting_period: Option<u32>,

		/// Optional vesting delay in blocks (e.g., "14400" for ~1 day with 6s blocks)
		#[arg(long)]
		vesting_delay: Option<u32>,

		/// Wallet name to sign with (creator)
		#[arg(long)]
		from: String,

		/// Password for the wallet
		#[arg(long)]
		password: Option<String>,

		/// Read password from file
		#[arg(long)]
		password_file: Option<String>,
	},

	/// Fund an existing airdrop with tokens
	Fund {
		/// Airdrop ID to fund
		#[arg(long)]
		airdrop_id: u32,

		/// Amount to fund (e.g., "10000.0")
		#[arg(long)]
		amount: String,

		/// Wallet name to sign with
		#[arg(long)]
		from: String,

		/// Password for the wallet
		#[arg(long)]
		password: Option<String>,

		/// Read password from file
		#[arg(long)]
		password_file: Option<String>,
	},

	/// Claim tokens from an airdrop (unsigned transaction)
	Claim {
		/// Airdrop ID to claim from
		#[arg(long)]
		airdrop_id: u32,

		/// Recipient address or wallet name
		#[arg(long)]
		recipient: String,

		/// Amount to claim (e.g., "100.0")
		#[arg(long)]
		amount: String,

		/// Merkle proof as comma-separated hex values
		/// Example: "0x1234...,0x5678...,0xabcd..."
		#[arg(long)]
		proof: String,
	},

	/// Delete an airdrop and reclaim remaining tokens (creator only)
	Delete {
		/// Airdrop ID to delete
		#[arg(long)]
		airdrop_id: u32,

		/// Wallet name to sign with (must be creator)
		#[arg(long)]
		from: String,

		/// Password for the wallet
		#[arg(long)]
		password: Option<String>,

		/// Read password from file
		#[arg(long)]
		password_file: Option<String>,
	},

	/// Show detailed information about an airdrop
	Info {
		/// Airdrop ID to query
		#[arg(long)]
		airdrop_id: u32,
	},

	/// List all airdrops
	List {
		/// Optional: filter by creator address or wallet name
		#[arg(long)]
		creator: Option<String>,
	},

	/// Check if an address has claimed from an airdrop
	CheckClaimed {
		/// Airdrop ID
		#[arg(long)]
		airdrop_id: u32,

		/// Address or wallet name to check
		#[arg(long)]
		address: String,
	},

	/// Generate Merkle tree from a CSV file (offline utility)
	GenerateTree {
		/// Path to CSV file with format: address,amount
		#[arg(long)]
		input: String,

		/// Output file for Merkle tree data (JSON)
		#[arg(long)]
		output: String,
	},

	/// Verify a Merkle proof offline
	VerifyProof {
		/// Merkle root (32-byte hex string)
		#[arg(long)]
		merkle_root: String,

		/// Address to verify
		#[arg(long)]
		address: String,

		/// Amount to verify
		#[arg(long)]
		amount: String,

		/// Merkle proof as comma-separated hex values
		#[arg(long)]
		proof: String,
	},

	/// Calculate leaf hash for an address and amount (offline utility)
	CalculateLeaf {
		/// Address
		#[arg(long)]
		address: String,

		/// Amount
		#[arg(long)]
		amount: String,
	},
}

/// Handle merkle-airdrop commands
pub async fn handle_merkle_airdrop_command(
	command: MerkleAirdropCommands,
	node_url: &str,
	finalized: bool,
) -> Result<()> {
	match command {
		MerkleAirdropCommands::Create {
			merkle_root,
			merkle_file,
			vesting_period,
			vesting_delay,
			from,
			password,
			password_file,
		} => {
			// Get merkle root from either --merkle-root or --merkle-file
			let root = if let Some(root) = merkle_root {
				root.clone()
			} else if let Some(file) = merkle_file {
				load_merkle_root_from_file(&file)?
			} else {
				return Err(crate::error::QuantusError::Generic(
					"Either --merkle-root or --merkle-file must be provided".to_string(),
				));
			};

			let quantus_client = QuantusClient::new(node_url).await?;
			handle_create(
				&quantus_client,
				&root,
				vesting_period,
				vesting_delay,
				&from,
				password,
				password_file,
				finalized,
			)
			.await
		},
		MerkleAirdropCommands::Fund { airdrop_id, amount, from, password, password_file } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_fund(
				&quantus_client,
				airdrop_id,
				&amount,
				&from,
				password,
				password_file,
				finalized,
			)
			.await
		},
		MerkleAirdropCommands::Claim { airdrop_id, recipient, amount, proof } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_claim(&quantus_client, airdrop_id, &recipient, &amount, &proof, finalized).await
		},
		MerkleAirdropCommands::Delete { airdrop_id, from, password, password_file } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_delete(&quantus_client, airdrop_id, &from, password, password_file, finalized)
				.await
		},
		MerkleAirdropCommands::Info { airdrop_id } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_info(&quantus_client, airdrop_id).await
		},
		MerkleAirdropCommands::List { creator } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_list(&quantus_client, creator.as_deref()).await
		},
		MerkleAirdropCommands::CheckClaimed { airdrop_id, address } => {
			let quantus_client = QuantusClient::new(node_url).await?;
			handle_check_claimed(&quantus_client, airdrop_id, &address).await
		},
		MerkleAirdropCommands::GenerateTree { input, output } =>
			handle_generate_tree(&input, &output).await,
		MerkleAirdropCommands::VerifyProof { merkle_root, address, amount, proof } =>
			handle_verify_proof(&merkle_root, &address, &amount, &proof).await,
		MerkleAirdropCommands::CalculateLeaf { address, amount } =>
			handle_calculate_leaf(&address, &amount).await,
	}
}

// ============================================================================
// Implementation functions
// ============================================================================

/// Create airdrop
#[allow(clippy::too_many_arguments)]
async fn handle_create(
	quantus_client: &QuantusClient,
	merkle_root: &str,
	vesting_period: Option<u32>,
	vesting_delay: Option<u32>,
	from: &str,
	password: Option<String>,
	password_file: Option<String>,
	finalized: bool,
) -> Result<()> {
	log_info!("üéÅ Creating merkle airdrop...");

	// Parse merkle root
	let merkle_root_bytes = parse_hex_to_32bytes(merkle_root)?;

	// Load keypair
	let keypair = crate::wallet::load_keypair_from_wallet(from, password, password_file)?;

	// Build transaction
	let tx = quantus_subxt::api::tx().merkle_airdrop().create_airdrop(
		merkle_root_bytes,
		vesting_period,
		vesting_delay,
	);

	log_verbose!("üìã Airdrop parameters:");
	log_verbose!("   Merkle Root: {}", format_hex(&merkle_root_bytes).bright_cyan());
	if let Some(period) = vesting_period {
		log_verbose!("   Vesting Period: {} blocks", period.to_string().bright_yellow());
	}
	if let Some(delay) = vesting_delay {
		log_verbose!("   Vesting Delay: {} blocks", delay.to_string().bright_yellow());
	}

	// Submit transaction
	submit_transaction(quantus_client, &keypair, tx, None, finalized).await?;

	log_success!("‚úÖ Airdrop created successfully!");
	log_info!("üí° Use 'quantus merkle-airdrop list' to find the airdrop ID");

	Ok(())
}

/// Fund airdrop
async fn handle_fund(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
	amount: &str,
	from: &str,
	password: Option<String>,
	password_file: Option<String>,
	finalized: bool,
) -> Result<()> {
	log_info!("üí∞ Funding airdrop #{}...", airdrop_id);

	// Parse amount
	let amount_planck = parse_amount(quantus_client, amount).await?;

	// Load keypair
	let keypair = crate::wallet::load_keypair_from_wallet(from, password, password_file)?;

	// Build transaction
	let tx = quantus_subxt::api::tx()
		.merkle_airdrop()
		.fund_airdrop(airdrop_id, amount_planck);

	log_verbose!("üìã Funding parameters:");
	log_verbose!("   Airdrop ID: {}", airdrop_id.to_string().bright_cyan());
	log_verbose!(
		"   Amount: {} ({})",
		format_token_amount(quantus_client, amount_planck).await?,
		amount_planck
	);

	// Submit transaction
	submit_transaction(quantus_client, &keypair, tx, None, finalized).await?;

	log_success!("‚úÖ Airdrop funded successfully!");
	log_info!("üí° Use 'quantus merkle-airdrop info --airdrop-id {}' to check balance", airdrop_id);

	Ok(())
}

/// Claim from airdrop (unsigned transaction)
async fn handle_claim(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
	recipient: &str,
	amount: &str,
	proof: &str,
	finalized: bool,
) -> Result<()> {
	log_info!("üéØ Claiming from airdrop #{}...", airdrop_id);

	// Resolve recipient
	let recipient_address = resolve_address(recipient)?;
	let recipient_account_id = parse_address_to_account_id(&recipient_address)?;
	let recipient_subxt = account_id_sp_to_subxt(&recipient_account_id);

	// Parse amount
	let amount_planck = parse_amount(quantus_client, amount).await?;

	// Parse merkle proof
	let merkle_proof = parse_merkle_proof(proof)?;

	log_verbose!("üìã Claim parameters:");
	log_verbose!("   Airdrop ID: {}", airdrop_id.to_string().bright_cyan());
	log_verbose!("   Recipient: {}", recipient_address.bright_cyan());
	log_verbose!("   Recipient AccountId32: {:?}", recipient_account_id);
	let recipient_bytes: &[u8; 32] = recipient_account_id.as_ref();
	log_verbose!("   Recipient bytes: {}", hex::encode(recipient_bytes));
	log_verbose!(
		"   Amount: {} ({})",
		format_token_amount(quantus_client, amount_planck).await?,
		amount_planck
	);
	log_verbose!("   Proof elements: {}", merkle_proof.len());
	for (i, proof_elem) in merkle_proof.iter().enumerate() {
		log_verbose!("   Proof[{}]: {}", i, format_hex(proof_elem));
	}

	// Calculate what the leaf hash should be
	let expected_leaf = calculate_leaf_hash_blake2(&recipient_account_id, amount_planck);
	log_verbose!("   Expected leaf hash: {}", format_hex(&expected_leaf));

	// Build unsigned transaction
	let merkle_proof_vec: Vec<[u8; 32]> = merkle_proof.into_iter().collect();

	// Submit as unsigned transaction
	log_verbose!("üì§ Submitting unsigned claim transaction...");

	// For unsigned extrinsic, we need to build it manually
	// Format: [version_byte] [pallet_index] [call_index] [args...]
	use codec::Encode;

	// Get pallet and call indices from metadata
	let metadata = quantus_client.client().metadata();
	let pallet_metadata = metadata.pallet_by_name("MerkleAirdrop").ok_or_else(|| {
		crate::error::QuantusError::NetworkError("MerkleAirdrop pallet not found".to_string())
	})?;
	let call_metadata = pallet_metadata.call_variant_by_name("claim").ok_or_else(|| {
		crate::error::QuantusError::NetworkError("claim call not found".to_string())
	})?;

	let pallet_index = pallet_metadata.index();
	let call_index = call_metadata.index;

	log_verbose!("üìã Pallet index: {}, Call index: {}", pallet_index, call_index);

	// Build call data: [pallet_index] [call_index] [args...]
	let mut call_bytes = Vec::new();

	// Pallet index
	call_bytes.push(pallet_index);

	// Call index
	call_bytes.push(call_index);

	// Encode arguments: airdrop_id, recipient, amount, merkle_proof
	log_verbose!("üîç ENCODING CLAIM CALL:");
	log_verbose!("   airdrop_id (u32): {}", airdrop_id);
	log_verbose!("   recipient (AccountId32): {:?}", recipient_subxt);
	log_verbose!("   amount_planck (u128): {}", amount_planck);
	log_verbose!("   amount_planck (hex): 0x{:032x}", amount_planck);
	log_verbose!("   merkle_proof length: {}", merkle_proof_vec.len());

	airdrop_id.encode_to(&mut call_bytes);
	recipient_subxt.encode_to(&mut call_bytes);
	amount_planck.encode_to(&mut call_bytes);
	// BoundedVec is encoded as a Vec (just the inner vec)
	merkle_proof_vec.encode_to(&mut call_bytes);

	log_verbose!("üì¶ Call data size: {} bytes", call_bytes.len());
	log_verbose!("üì¶ Call data hex: 0x{}", hex::encode(&call_bytes));

	// Build full unsigned extrinsic with proper structure
	// Extrinsic format: [compact_length] [version_and_signature_type] [call]
	let mut extrinsic_bytes = Vec::new();

	// Version byte: 0x04 = version 4, unsigned (bit 7 = 0)
	extrinsic_bytes.push(0x04u8);

	// Append call data
	extrinsic_bytes.extend_from_slice(&call_bytes);

	// Add compact length prefix
	use codec::Compact;
	let length = Compact(extrinsic_bytes.len() as u32);
	let mut full_extrinsic = length.encode();
	full_extrinsic.extend_from_slice(&extrinsic_bytes);

	log_verbose!("üì¶ Full extrinsic size: {} bytes", full_extrinsic.len());
	log_verbose!("üì¶ Full extrinsic hex: 0x{}", hex::encode(&full_extrinsic));

	// Submit unsigned transaction via RPC
	use jsonrpsee::{core::client::ClientT, rpc_params};

	let tx_hash: subxt::config::substrate::H256 = quantus_client
		.rpc_client()
		.request("author_submitExtrinsic", rpc_params![hex::encode(&full_extrinsic)])
		.await
		.map_err(|e| {
			crate::error::QuantusError::NetworkError(format!(
				"Failed to submit unsigned transaction: {}",
				e
			))
		})?;

	log_success!("‚úÖ Claim transaction submitted!");
	log_info!("   Transaction hash: {:?}", tx_hash);

	// Wait for inclusion/finalization
	if finalized {
		log_verbose!("‚è≥ Waiting for finalization...");
		tokio::time::sleep(tokio::time::Duration::from_secs(6)).await;
		log_info!("üí° Transaction should be finalized");
	} else {
		log_verbose!("‚è≥ Waiting for block inclusion...");
		tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
		log_info!("üí° Transaction should be included in block");
	}

	log_info!("üí° Check recipient balance: quantus balance {}", recipient);

	Ok(())
}

/// Delete airdrop
async fn handle_delete(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
	from: &str,
	password: Option<String>,
	password_file: Option<String>,
	finalized: bool,
) -> Result<()> {
	log_info!("üóëÔ∏è  Deleting airdrop #{}...", airdrop_id);

	// Load keypair
	let keypair = crate::wallet::load_keypair_from_wallet(from, password, password_file)?;

	// Build transaction
	let tx = quantus_subxt::api::tx().merkle_airdrop().delete_airdrop(airdrop_id);

	log_verbose!("‚ö†Ô∏è  This will:");
	log_verbose!("   1. Return all unclaimed tokens to the creator");
	log_verbose!("   2. Remove the airdrop");

	// Submit transaction
	submit_transaction(quantus_client, &keypair, tx, None, finalized).await?;

	log_success!("‚úÖ Airdrop deleted successfully!");
	log_info!("üí° Unclaimed tokens have been returned to the creator");

	Ok(())
}

/// Show airdrop information
async fn handle_info(quantus_client: &QuantusClient, airdrop_id: u32) -> Result<()> {
	log_info!("üîç Fetching airdrop #{}...", airdrop_id);

	// Query airdrop from storage
	let airdrop = get_airdrop_info(quantus_client, airdrop_id).await?;

	if airdrop.is_none() {
		log_error!("‚ùå Airdrop #{} not found", airdrop_id);
		return Ok(());
	}

	let airdrop = airdrop.unwrap();
	let (_, decimals) = get_chain_properties(quantus_client).await?;

	log_print!("");
	log_print!("{}", format!("Airdrop #{}", airdrop_id).bright_cyan().bold());
	log_print!("{}", "‚îÄ".repeat(60).dimmed());

	// Basic info
	log_print!("  {}: {}", "Creator".bright_white(), account_id_to_ss58(&airdrop.creator));
	log_print!(
		"  {}: {}",
		"Merkle Root".bright_white(),
		format_hex(&airdrop.merkle_root).bright_cyan()
	);
	log_print!(
		"  {}: {} ({})",
		"Balance".bright_white(),
		format_balance(airdrop.balance, decimals).bright_green(),
		airdrop.balance
	);

	log_print!("");

	// Vesting info
	log_print!("  {}", "Vesting".bright_white().bold());
	if let Some(period) = airdrop.vesting_period {
		log_print!("  {}: {} blocks", "Period".bright_white(), period.to_string().bright_yellow());
	} else {
		log_print!("  {}: {}", "Period".bright_white(), "None (immediate transfer)".bright_green());
	}

	if let Some(delay) = airdrop.vesting_delay {
		log_print!("  {}: {} blocks", "Delay".bright_white(), delay.to_string().bright_yellow());
	} else {
		log_print!("  {}: {}", "Delay".bright_white(), "None (starts immediately)".bright_green());
	}

	log_print!("");

	Ok(())
}

/// List airdrops
async fn handle_list(quantus_client: &QuantusClient, creator_filter: Option<&str>) -> Result<()> {
	log_info!("üîç Fetching airdrops...");

	let creator_subxt = if let Some(creator) = creator_filter {
		let resolved = resolve_address(creator)?;
		let account = parse_address_to_account_id(&resolved)?;
		Some(account_id_sp_to_subxt(&account))
	} else {
		None
	};

	// Get next airdrop ID to know range
	let next_id = get_next_airdrop_id(quantus_client).await?;

	if next_id == 0 {
		log_info!("‚ÑπÔ∏è  No airdrops found");
		return Ok(());
	}

	let (_, decimals) = get_chain_properties(quantus_client).await?;
	let mut found = 0;

	log_print!("");

	for id in 0..next_id {
		if let Some(airdrop) = get_airdrop_info(quantus_client, id).await? {
			// Filter by creator if specified
			if let Some(ref filter_creator) = creator_subxt {
				if &airdrop.creator != filter_creator {
					continue;
				}
			}

			found += 1;

			let vesting_info = if airdrop.vesting_period.is_some() {
				"Vested".bright_magenta()
			} else {
				"Immediate".bright_green()
			};

			log_print!(
				"  {} {} | {} {} | {} {} | {}",
				"#".dimmed(),
				id.to_string().bright_cyan(),
				"Creator:".dimmed(),
				account_id_to_ss58(&airdrop.creator).bright_white(),
				"Balance:".dimmed(),
				format_balance(airdrop.balance, decimals).bright_green(),
				vesting_info
			);
		}
	}

	if found == 0 {
		log_info!("‚ÑπÔ∏è  No airdrops found");
	} else {
		log_print!("");
		log_success!("Found {} airdrop(s)", found);
		log_info!("üí° Use 'quantus merkle-airdrop info --airdrop-id <ID>' for details");
	}

	Ok(())
}

/// Check if address has claimed
async fn handle_check_claimed(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
	address: &str,
) -> Result<()> {
	log_info!("üîç Checking claim status for airdrop #{}...", airdrop_id);

	let resolved_address = resolve_address(address)?;
	let account_id = parse_address_to_account_id(&resolved_address)?;
	let account_subxt = account_id_sp_to_subxt(&account_id);

	let claimed = is_claimed(quantus_client, airdrop_id, &account_subxt).await?;

	log_print!("");
	log_print!("  {}: {}", "Airdrop ID".bright_white(), airdrop_id.to_string().bright_cyan());
	log_print!("  {}: {}", "Address".bright_white(), resolved_address.bright_cyan());
	log_print!("");

	if claimed {
		log_print!("  {}: {}", "Status".bright_white(), "‚úÖ Already Claimed".bright_green());
	} else {
		log_print!("  {}: {}", "Status".bright_white(), "‚è≥ Not Claimed Yet".bright_yellow());
	}

	log_print!("");

	Ok(())
}

/// Generate Merkle tree from CSV (offline utility)
async fn handle_generate_tree(input: &str, output: &str) -> Result<()> {
	log_info!("üå≥ Generating Merkle tree from {}...", input.bright_cyan());
	log_info!("   Using {} decimals (Quantus standard)", QUANTUS_DECIMALS);

	// Read CSV file
	let csv_content = std::fs::read_to_string(input).map_err(|e| {
		crate::error::QuantusError::Generic(format!("Failed to read CSV file: {}", e))
	})?;

	// Parse CSV (address, amount)
	let mut leaves: Vec<(String, u128)> = Vec::new();

	for (line_num, line) in csv_content.lines().enumerate() {
		let line = line.trim();
		if line.is_empty() || line.starts_with('#') {
			continue; // Skip empty lines and comments
		}

		let parts: Vec<&str> = line.split(',').map(|s| s.trim()).collect();
		if parts.len() != 2 {
			return Err(crate::error::QuantusError::Generic(format!(
				"Invalid CSV format at line {}: expected 'address,amount'",
				line_num + 1
			)));
		}

		let address = parts[0];
		let amount_str = parts[1];

		// Validate address
		let _ = SpAccountId32::from_ss58check(address).map_err(|_| {
			crate::error::QuantusError::Generic(format!(
				"Invalid address at line {}: {}",
				line_num + 1,
				address
			))
		})?;

		// Parse amount (support decimal notation)
		let amount = if amount_str.contains('.') {
			let parts: Vec<&str> = amount_str.split('.').collect();
			let integer_part: u128 = parts[0].parse().map_err(|_| {
				crate::error::QuantusError::Generic(format!(
					"Invalid amount at line {}",
					line_num + 1
				))
			})?;
			let decimal_part_str = if parts.len() > 1 { parts[1] } else { "0" };
			let decimal_part: u128 = decimal_part_str.parse().map_err(|_| {
				crate::error::QuantusError::Generic(format!(
					"Invalid amount at line {}",
					line_num + 1
				))
			})?;
			let multiplier = 10u128.pow(QUANTUS_DECIMALS - decimal_part_str.len() as u32);
			integer_part * 10u128.pow(QUANTUS_DECIMALS) + decimal_part * multiplier
		} else {
			amount_str.parse().map_err(|_| {
				crate::error::QuantusError::Generic(format!(
					"Invalid amount at line {}",
					line_num + 1
				))
			})?
		};

		leaves.push((address.to_string(), amount));
	}

	log_info!("üìã Parsed {} entries from CSV", leaves.len());

	if leaves.is_empty() {
		return Err(crate::error::QuantusError::Generic("CSV file is empty".to_string()));
	}

	// Build Merkle tree
	let (merkle_root, proofs) = build_merkle_tree(&leaves)?;

	log_success!("üå≥ Merkle tree generated!");
	log_info!("   Root: {}", format_hex(&merkle_root).bright_cyan());
	log_info!("   Leaves: {}", leaves.len());

	// Prepare output data
	let output_data = MerkleTreeOutput { root: format_hex(&merkle_root), proofs, leaves };

	// Write to JSON
	let json = serde_json::to_string_pretty(&output_data).map_err(|e| {
		crate::error::QuantusError::Generic(format!("Failed to serialize JSON: {}", e))
	})?;

	std::fs::write(output, json).map_err(|e| {
		crate::error::QuantusError::Generic(format!("Failed to write output file: {}", e))
	})?;

	log_success!("‚úÖ Merkle tree saved to {}", output.bright_cyan());
	log_info!("");
	log_info!("üí° Next steps:");
	log_info!(
		"   1. Create airdrop: quantus merkle-airdrop create --merkle-root {} --from <WALLET>",
		format_hex(&merkle_root)
	);
	log_info!("   2. Fund airdrop: quantus merkle-airdrop fund --airdrop-id <ID> --amount <TOTAL> --from <WALLET>");
	log_info!("   3. Share {} with recipients so they can claim", output.bright_cyan());

	Ok(())
}

/// Verify Merkle proof offline
async fn handle_verify_proof(
	merkle_root: &str,
	address: &str,
	amount: &str,
	proof: &str,
) -> Result<()> {
	log_info!("üîç Verifying Merkle proof...");

	// Parse inputs
	let merkle_root_bytes = parse_hex_to_32bytes(merkle_root)?;
	let account_id = SpAccountId32::from_ss58check(address).map_err(|_| {
		crate::error::QuantusError::Generic(format!("Invalid address: {}", address))
	})?;
	let amount_planck: u128 = amount
		.parse()
		.map_err(|_| crate::error::QuantusError::Generic(format!("Invalid amount: {}", amount)))?;
	let merkle_proof = parse_merkle_proof(proof)?;

	log_verbose!("üìã Verification parameters:");
	log_verbose!("   Merkle Root: {}", format_hex(&merkle_root_bytes).bright_cyan());
	log_verbose!("   Address: {}", address.bright_cyan());
	log_verbose!("   Amount: {}", amount_planck);
	log_verbose!("   Proof elements: {}", merkle_proof.len());

	// Verify proof
	let valid =
		verify_merkle_proof_blake2(&account_id, amount_planck, &merkle_root_bytes, &merkle_proof);

	log_print!("");
	if valid {
		log_success!("‚úÖ Proof is VALID");
		log_info!("üí° This address can claim {} tokens from the airdrop", amount_planck);
	} else {
		log_error!("‚ùå Proof is INVALID");
		log_error!("‚ö†Ô∏è  This claim will fail if submitted to the chain");
	}
	log_print!("");

	Ok(())
}

/// Calculate leaf hash
async fn handle_calculate_leaf(address: &str, amount: &str) -> Result<()> {
	log_info!("üçÉ Calculating leaf hash...");

	// Parse inputs
	let account_id = SpAccountId32::from_ss58check(address).map_err(|_| {
		crate::error::QuantusError::Generic(format!("Invalid address: {}", address))
	})?;
	let amount_planck: u128 = amount
		.parse()
		.map_err(|_| crate::error::QuantusError::Generic(format!("Invalid amount: {}", amount)))?;

	// Calculate leaf hash using Blake2 (matching pallet implementation)
	let leaf_hash = calculate_leaf_hash_blake2(&account_id, amount_planck);

	log_print!("");
	log_print!("  {}: {}", "Address".bright_white(), address.bright_cyan());
	log_print!("  {}: {}", "Amount".bright_white(), amount_planck.to_string().bright_green());
	log_print!("  {}: {}", "Leaf Hash".bright_white(), format_hex(&leaf_hash).bright_yellow());
	log_print!("");

	Ok(())
}

// ============================================================================
// Helper functions
// ============================================================================

/// Parse hex string to 32-byte array
fn parse_hex_to_32bytes(hex: &str) -> Result<[u8; 32]> {
	let hex = hex.trim().trim_start_matches("0x");

	if hex.len() != 64 {
		return Err(crate::error::QuantusError::Generic(format!(
			"Invalid hex length: expected 64 characters (32 bytes), got {}",
			hex.len()
		)));
	}

	let mut bytes = [0u8; 32];
	for i in 0..32 {
		bytes[i] = u8::from_str_radix(&hex[i * 2..i * 2 + 2], 16).map_err(|_| {
			crate::error::QuantusError::Generic(format!(
				"Invalid hex character at position {}",
				i * 2
			))
		})?;
	}

	Ok(bytes)
}

/// Format bytes as hex string
fn format_hex(bytes: &[u8]) -> String {
	format!("0x{}", hex::encode(bytes))
}

/// Parse Merkle proof from comma-separated hex strings
fn parse_merkle_proof(proof: &str) -> Result<Vec<[u8; 32]>> {
	let proof = proof.trim();
	if proof.is_empty() {
		return Ok(Vec::new());
	}

	let parts: Vec<&str> = proof.split(',').map(|s| s.trim()).collect();
	let mut proof_elements = Vec::new();

	for (i, part) in parts.iter().enumerate() {
		let element = parse_hex_to_32bytes(part).map_err(|e| {
			crate::error::QuantusError::Generic(format!("Invalid proof element #{}: {}", i, e))
		})?;
		proof_elements.push(element);
	}

	Ok(proof_elements)
}

/// Parse SS58 address to AccountId32
fn parse_address_to_account_id(address: &str) -> Result<SpAccountId32> {
	let (account_id, _) = SpAccountId32::from_ss58check_with_version(address)
		.map_err(|e| crate::error::QuantusError::Generic(format!("Invalid address: {:?}", e)))?;
	Ok(account_id)
}

/// Convert sp_core AccountId32 to subxt AccountId32
fn account_id_sp_to_subxt(
	account_id: &SpAccountId32,
) -> subxt::ext::subxt_core::utils::AccountId32 {
	let bytes: [u8; 32] = *account_id.as_ref();
	subxt::ext::subxt_core::utils::AccountId32::from(bytes)
}

/// Convert AccountId32 to SS58 string
fn account_id_to_ss58(account_id: &subxt::ext::subxt_core::utils::AccountId32) -> String {
	let bytes: [u8; 32] = account_id.0;
	let sp_account = SpAccountId32::from(bytes);
	sp_account.to_ss58check()
}

/// Format token amount with symbol
async fn format_token_amount(quantus_client: &QuantusClient, amount: u128) -> Result<String> {
	let (symbol, decimals) = get_chain_properties(quantus_client).await?;
	Ok(format!("{} {}", format_balance(amount, decimals), symbol))
}

/// Get airdrop info from storage
async fn get_airdrop_info(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
) -> Result<
	Option<
		quantus_subxt::api::runtime_types::pallet_merkle_airdrop::AirdropMetadata<
			u32,
			u128,
			subxt::ext::subxt_core::utils::AccountId32,
		>,
	>,
> {
	use quantus_subxt::api;

	let latest_block = quantus_client.get_latest_block().await?;
	let storage_at = quantus_client.client().storage().at(latest_block);

	let airdrop_addr = api::storage().merkle_airdrop().airdrop_info(airdrop_id);
	let airdrop = storage_at.fetch(&airdrop_addr).await.map_err(|e| {
		crate::error::QuantusError::NetworkError(format!("Failed to fetch airdrop: {}", e))
	})?;

	Ok(airdrop)
}

/// Get next airdrop ID
async fn get_next_airdrop_id(quantus_client: &QuantusClient) -> Result<u32> {
	use quantus_subxt::api;

	let latest_block = quantus_client.get_latest_block().await?;
	let storage_at = quantus_client.client().storage().at(latest_block);

	let next_id_addr = api::storage().merkle_airdrop().next_airdrop_id();
	let next_id = storage_at.fetch_or_default(&next_id_addr).await.map_err(|e| {
		crate::error::QuantusError::NetworkError(format!("Failed to fetch next airdrop ID: {}", e))
	})?;

	Ok(next_id)
}

/// Check if address has claimed from airdrop
async fn is_claimed(
	quantus_client: &QuantusClient,
	airdrop_id: u32,
	account: &subxt::ext::subxt_core::utils::AccountId32,
) -> Result<bool> {
	use quantus_subxt::api;

	let latest_block = quantus_client.get_latest_block().await?;
	let storage_at = quantus_client.client().storage().at(latest_block);

	let claimed_addr = api::storage().merkle_airdrop().claimed(airdrop_id, account.clone());
	let claimed = storage_at.fetch(&claimed_addr).await.map_err(|e| {
		crate::error::QuantusError::NetworkError(format!("Failed to check claimed status: {}", e))
	})?;

	Ok(claimed.is_some())
}

// ============================================================================
// Merkle tree utilities (Blake2)
// ============================================================================

/// Calculate leaf hash using Blake2 (matching pallet implementation)
fn calculate_leaf_hash_blake2(account: &SpAccountId32, amount: u128) -> [u8; 32] {
	use sp_io::hashing::blake2_256;

	// SCALE encoding of tuple (account, amount) - matches pallet implementation
	// For 2-element tuple, this is equivalent to concatenating encoded elements
	let bytes = (account, amount).encode();
	blake2_256(&bytes)
}

/// Calculate parent hash using Blake2 (matching pallet implementation)
fn calculate_parent_hash_blake2(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
	use sp_io::hashing::blake2_256;

	// Ensure consistent ordering (important for verification)
	let combined = if left < right {
		[left.as_slice(), right.as_slice()].concat()
	} else {
		[right.as_slice(), left.as_slice()].concat()
	};

	blake2_256(&combined)
}

/// Verify Merkle proof using Blake2 (matching pallet implementation)
fn verify_merkle_proof_blake2(
	account: &SpAccountId32,
	amount: u128,
	merkle_root: &[u8; 32],
	merkle_proof: &[[u8; 32]],
) -> bool {
	let leaf = calculate_leaf_hash_blake2(account, amount);

	// Verify the proof by walking up the tree
	let mut computed_hash = leaf;
	for proof_element in merkle_proof.iter() {
		computed_hash = if computed_hash < *proof_element {
			calculate_parent_hash_blake2(&computed_hash, proof_element)
		} else {
			calculate_parent_hash_blake2(proof_element, &computed_hash)
		};
	}

	computed_hash == *merkle_root
}

/// Build Merkle tree from leaves
fn build_merkle_tree(leaves: &[(String, u128)]) -> Result<MerkleTreeResult> {
	if leaves.is_empty() {
		return Err(crate::error::QuantusError::Generic(
			"Cannot build tree from empty list".to_string(),
		));
	}

	// Calculate all leaf hashes
	let mut leaf_hashes: Vec<([u8; 32], String)> = Vec::new();
	for (address, amount) in leaves {
		let account_id = SpAccountId32::from_ss58check(address).map_err(|_| {
			crate::error::QuantusError::Generic(format!("Invalid address: {}", address))
		})?;
		let leaf_hash = calculate_leaf_hash_blake2(&account_id, *amount);
		leaf_hashes.push((leaf_hash, address.clone()));
	}

	// Sort leaves for consistent tree structure
	leaf_hashes.sort_by(|a, b| a.0.cmp(&b.0));

	// Build tree level by level
	let mut current_level: Vec<[u8; 32]> = leaf_hashes.iter().map(|(hash, _)| *hash).collect();
	let mut all_levels: Vec<Vec<[u8; 32]>> = vec![current_level.clone()];

	while current_level.len() > 1 {
		let mut next_level = Vec::new();

		for chunk in current_level.chunks(2) {
			let hash = if chunk.len() == 2 {
				calculate_parent_hash_blake2(&chunk[0], &chunk[1])
			} else {
				// Odd node - hash with itself
				calculate_parent_hash_blake2(&chunk[0], &chunk[0])
			};
			next_level.push(hash);
		}

		all_levels.push(next_level.clone());
		current_level = next_level;
	}

	let merkle_root = current_level[0];

	// Generate proofs for each leaf
	let mut proofs: HashMap<String, Vec<String>> = HashMap::new();

	for (leaf_idx, (_leaf_hash, address)) in leaf_hashes.iter().enumerate() {
		let mut proof = Vec::new();
		let mut current_idx = leaf_idx;

		for level in &all_levels[..all_levels.len() - 1] {
			// Skip root level
			let sibling_idx = if current_idx % 2 == 0 { current_idx + 1 } else { current_idx - 1 };

			if sibling_idx < level.len() {
				proof.push(format_hex(&level[sibling_idx]));
			} else {
				// Odd node - sibling is itself
				proof.push(format_hex(&level[current_idx]));
			}

			current_idx /= 2;
		}

		proofs.insert(address.clone(), proof);
	}

	Ok((merkle_root, proofs))
}

// ============================================================================
// Data structures for JSON output
// ============================================================================

/// Type alias for Merkle tree generation result (root hash + proofs map)
type MerkleTreeResult = ([u8; 32], HashMap<String, Vec<String>>);

#[derive(Serialize, Deserialize)]
struct MerkleTreeOutput {
	root: String,
	proofs: HashMap<String, Vec<String>>,
	leaves: Vec<(String, u128)>,
}
